>>What is a calculator? (in this case)
A program that takes numerical values and performs some desired operation (logic) with those values, returning the result.
    A program is a set of functions (smaller sets of instructions) combined to complete a task.

>>How do I want the calculator to work?
Receive one or two numerical arguments (integers) to be evaluated and one to determine the method of evaluation. Return the end result.
    Use 'if' compound statements (if/elif/else) to ascertain the specific operation to be performed.
        'if': If some element(s) meet some criteria, then perform some set of instructions.
        'elif': If the prior 'if' or 'elif' did not have its criteria met, then run this 'if' statement instead.
        'else': If the prior 'if' or 'elif' did not have its criteria met, then perform some task (that may or may not include an if statement).
        Compound Statements: (recall lines 64 and 65 of hello_world_notes.txt)

>>(Python)
>Define the function and its arguments with the option for no arguments.
    def calc(x=None, op=None, y=None):

>Return the operator codes when no arguments are given.
    if x == None and op == None and y == None:
        return f"Add: 0\nSub: 1\nMul: 2\nDiv: 3 <etc>"

[single-argument statements]
>Evaluate arguments only if the first two arguments are received and they are integers.
    if type(x) == int and type(op) == int and y == None:
        # perform desired operation statement (lines 31 to 90)
    else:
        return <error string>
    
    # OR, for just checking that all arguments are given:
    if x != None and op != None and y == None:

>Absolute value statement
 -Set the operator code condition and return the result of the function.
    if op == 0:
        if x >= 0:
            return x
        else:
            return -x

>Factorial statement
 -Only allow numbers larger than 1.
 -Multiply integers together from 1 to x with a for loop.
    elif op == 1 and x > 1:
        for k in range(1, x):
            x = x * k
        return x

>Square root statement
 -Use optimized version of the square root approximation function from three_functions2.py.
 -While loop switched to for loop.
 -Guess is now prechosen.
    elif op == 2:
        temp = 1
        for k in range (0, 100):
            temp = (temp + (x / temp)) / 2
        return temp

>Decimal to binary conversion statement
 -Look for the largest 'x', where 2^x <= decimal input.
 -Decrement 'pwr' to correct the last increment that ended the loop.
    pwr = 0
    while 2 ** pwr <= dec_num:
        pwr += 1
    pwr -= 1

 -Create a list with 'x' zeros for storing the binary digits later.
    binlst = []
    for k in range(0, pwr):
        binlst.append(0)

 -Check if the sum of descending powers of two is larger than the decimal input.
 -If so, subtract the last power of two added to the sum.
 -If not, update the 'xth' position of the binary list from 0 to 1.
    psum = 2 ** pwr
    for k in range(1, pwr + 1):
        psum += (2 ** (pwr - k))
        if psum > dec_num:
            psum -= (2 ** (pwr - k))
        else:
            binlst[pwr - k] = 1

 -Collect the digits into a single string (inverting digit order).
 -Start with "1" as the first digit because all binary numbers greater than zero start with a one.
    bin_num = "1"
    k = pwr - 1
    while k >= 0: # concatenate binary digits
        bin_num += str(binlst[k])
        k -= 1

 -Output the compiled value as a string or an integer.
    return bin_num # OR: int(bin_num)

>Incorrect operator code statement
    else:
        return <error string>

[dual-argument statements]
>Evaluate arguments only if all arguments are received and they are integers.
    if type(x) == int and type(op) == int and type(y) == int:
        # perform desired operation statement (lines 106 to 137)
    else:
        return <error string>
    
    # OR:
    if x != None and op != None and y != None:

>Addition statement
    if op == 0:
        return x + y

>Subtraction statement
    elif op == 1:
        return x - y

>Multiplication statement
    elif op == 2:
        return x * y

>Division statement
    elif op == 3:
        return x / y

>Power statement
    elif op == 4:
        return x ** y

>Concatenation statement
 -Convert integers to strings so the values are concatenated instead of added.
 -Convert the result back to an integer for use in other calculations.
    elif op == 5:
        x = str(x)
        y = str(y)
        temp = x + y
        return int(temp)

>Modulo statement
    elif op == 6:
        return x % y

>Incorrect operator code statement
    else:
        return <error string>
